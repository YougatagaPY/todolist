const express = require('express');
const cors = require('cors');
const { Sequelize, DataTypes } = require('sequelize');
const path = require('path');

// Charger les variables d'environnement
require('dotenv').config();

const app = express();
const PORT = 3001;

// Configuration de la base de donn√©es SQLite
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'database.db',
  logging: false
});

// Mod√®le Task
const Task = sequelize.define('Task', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    defaultValue: ''
  },
  status: {
    type: DataTypes.ENUM('todo', 'in_progress', 'completed'),
    defaultValue: 'todo'
  },
  completed: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  },
  priority: {
    type: DataTypes.ENUM('low', 'medium', 'high', 'urgent'),
    defaultValue: 'medium'
  },
  stressLevel: {
    type: DataTypes.INTEGER,
    defaultValue: 1,
    validate: { min: 1, max: 5 }
  },
  dueDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  tags: {
    type: DataTypes.STRING,
    defaultValue: ''
  },
  aiSuggestions: {
    type: DataTypes.TEXT,
    defaultValue: ''
  }
});

// ‚ö†Ô∏è MIDDLEWARE DOIT √äTRE EN PREMIER !
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, '../frontend')));

// Routes API

// GET - Lister toutes les t√¢ches
app.get('/api/tasks', async (req, res) => {
  try {
    const tasks = await Task.findAll({
      order: [['createdAt', 'DESC']]
    });
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// POST - Cr√©er une nouvelle t√¢che
app.post('/api/tasks', async (req, res) => {
  try {
    const { title, description, priority, dueDate, tags } = req.body;
    
    // Calcul du niveau de stress bas√© sur l'IA
    const stressLevel = calculateStressLevel(title, description, priority);
    const aiSuggestions = generateAISuggestions(title, description);
    
    const task = await Task.create({
      title,
      description,
      priority,
      stressLevel,
      dueDate,
      tags,
      aiSuggestions
    });
    
    res.status(201).json(task);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// PUT - Modifier une t√¢che
app.put('/api/tasks/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    const task = await Task.findByPk(id);
    if (!task) {
      return res.status(404).json({ error: 'T√¢che non trouv√©e' });
    }
    
    // Synchroniser completed et status
    if (updates.status) {
      updates.completed = updates.status === 'completed';
    } else if (updates.completed !== undefined) {
      updates.status = updates.completed ? 'completed' : 'todo';
    }
    
    // Recalcul du stress si n√©cessaire
    if (updates.title || updates.description || updates.priority) {
      updates.stressLevel = calculateStressLevel(
        updates.title || task.title,
        updates.description || task.description,
        updates.priority || task.priority
      );
    }
    
    await task.update(updates);
    res.json(task);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// DELETE - Supprimer une t√¢che
app.delete('/api/tasks/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const task = await Task.findByPk(id);
    
    if (!task) {
      return res.status(404).json({ error: 'T√¢che non trouv√©e' });
    }
    
    await task.destroy();
    res.json({ message: 'T√¢che supprim√©e avec succ√®s' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// GET - Export JSON
app.get('/api/tasks/export', async (req, res) => {
  try {
    const tasks = await Task.findAll();
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', 'attachment; filename=tasks-export.json');
    res.json({
      exportDate: new Date().toISOString(),
      totalTasks: tasks.length,
      tasks: tasks
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// POST - R√©√©criture professionnelle avec Perplexity AI
app.post('/api/ai/rewrite', async (req, res) => {
  try {
    const { text, style = 'professional' } = req.body;
    
    if (!text || text.trim().length === 0) {
      return res.status(400).json({ error: 'Texte √† r√©√©crire requis' });
    }

    const rewrittenText = await rewriteWithPerplexity(text, style);
    
    res.json({
      success: true,
      rewrittenText: rewrittenText,
      originalText: text,
      style: style,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Erreur r√©√©criture IA:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©√©criture IA',
      fallback: generateFallbackRewrite(req.body?.text || '', req.body?.style || 'professional')
    });
  }
});

// POST - Analyse vocale et cr√©ation de t√¢che
app.post('/api/tasks/voice', async (req, res) => {
  try {
    const { transcript } = req.body;
    const parsedTask = parseVoiceInput(transcript);
    
    const task = await Task.create({
      ...parsedTask,
      stressLevel: calculateStressLevel(parsedTask.title, parsedTask.description, parsedTask.priority),
      aiSuggestions: generateAISuggestions(parsedTask.title, parsedTask.description)
    });
    
    res.status(201).json(task);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Fonction de r√©√©criture avec Perplexity AI - VERSION S√âCURIS√âE
async function rewriteWithPerplexity(text, style) {
    // ‚úÖ S√âCURIS√â : R√©cup√©rer la cl√© depuis les variables d'environnement uniquement
    const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
    
    // ‚úÖ S√âCURIS√â : Ne pas logger la cl√©, juste v√©rifier sa pr√©sence
    console.log('üîë V√©rification cl√© API Perplexity:', PERPLEXITY_API_KEY ? 'Pr√©sente' : 'Manquante');
    
    if (!PERPLEXITY_API_KEY) {
      console.warn('‚ö†Ô∏è Cl√© API Perplexity manquante, utilisation du fallback');
      return generateFallbackRewrite(text, style);
    }
  
    const prompt = createRewritePrompt(text, style);
    
    try {
      const response = await fetch('https://api.perplexity.ai/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${PERPLEXITY_API_KEY}`
        },
        body: JSON.stringify({
          model: 'llama-3.1-sonar-small-128k-online',
          messages: [
            {
              role: 'system',
              content: 'Tu es un expert en r√©daction professionnelle. Reformule le texte selon le style demand√© en gardant le sens original. R√©ponds uniquement avec le texte reformul√©, sans explication.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          max_tokens: 500,
          temperature: 0.3
        })
      });
  
      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`Erreur API Perplexity: ${response.status} - ${errorData}`);
      }
  
      const data = await response.json();
      return data.choices[0].message.content.trim();
      
    } catch (error) {
      console.error('Erreur Perplexity API:', error);
      return generateFallbackRewrite(text, style);
    }
  }

function createRewritePrompt(text, style) {
    const styleInstructions = {
      professional: 'Reformule ce texte de mani√®re professionnelle et claire, adapt√© pour un environnement de travail.',
      correct: 'Corrige les fautes d\'orthographe, de grammaire et de conjugaison dans ce texte tout en gardant le sens original.',
      formal: 'R√©√©cris ce texte dans un style formel et soutenu, avec un vocabulaire pr√©cis.',
      concise: 'Reformule ce texte de mani√®re tr√®s concise et directe, en √©liminant les mots superflus.',
      detailed: 'D√©veloppe et enrichis ce texte en ajoutant des d√©tails pertinents et des pr√©cisions.',
      friendly: 'R√©√©cris ce texte dans un ton amical et accessible, tout en restant professionnel.',
      technical: 'Reformule ce texte avec un vocabulaire technique et pr√©cis, adapt√© √† un contexte professionnel sp√©cialis√©.'
    };
  
    const instruction = styleInstructions[style] || styleInstructions.professional;
  
    // D√©tecter si c'est une demande de titre+description
    if (text.includes('Titre:') && text.includes('Description:')) {
      return `${instruction}
  
  ${text}
  
  IMPORTANT: Retourne le r√©sultat au format suivant pour une t√¢che:
  - Une premi√®re phrase courte et claire pour le titre (max 80 caract√®res)
  - Un point ou deux points
  - Puis une description plus d√©taill√©e
  
  Exemple: "Finaliser le rapport mensuel. Compiler les donn√©es de vente, analyser les tendances et pr√©parer la pr√©sentation pour la direction."
  
  Ne mets pas de guillemets autour de ta r√©ponse.`;
    }
  
    // Pour les autres cas (titre seul ou description seule)
    return `${instruction}
  
  Texte √† r√©√©crire :
  "${text}"
  
  Garde le m√™me sens mais am√©liore la formulation. Retourne uniquement le texte r√©√©crit, sans commentaires ni guillemets.`;
  }

function generateFallbackRewrite(text, style) {
  // R√©√©criture de secours si Mistral n'est pas disponible
  const improvements = {
    professional: {
      replacements: [
        ['faire', 'r√©aliser'],
        ['voir', 'examiner'],
        ['finir', 'finaliser'],
        ['commencer', 'initier'],
        ['changer', 'modifier']
      ],
      prefix: 'Objectif : '
    },
    correct: {
      replacements: [
        ['ca', 'cela'],
        ['pk', 'pourquoi'],
        ['tjrs', 'toujours'],
        ['vs', 'vous'],
        ['dc', 'donc']
      ],
      prefix: ''
    },
    formal: {
      replacements: [
        ['ok', 'valid√©'],
        ['super', 'excellent'],
        ['probl√®me', 'probl√©matique']
      ],
      prefix: 'Il convient de : '
    },
    concise: {
      replacements: [
        ['il faut que je', 'je dois'],
        ['il est n√©cessaire de', ''],
        ['afin de', 'pour']
      ],
      prefix: ''
    },
    technical: {
      replacements: [
        ['faire', 'impl√©menter'],
        ['v√©rifier', 'valider'],
        ['probl√®me', 'dysfonctionnement']
      ],
      prefix: 'Proc√©dure : '
    }
  };

  let rewritten = text || 'Texte non fourni';
  const config = improvements[style] || improvements.professional;
  
  // Appliquer les remplacements
  config.replacements.forEach(([from, to]) => {
    const regex = new RegExp(from, 'gi');
    rewritten = rewritten.replace(regex, to);
  });
  
  // Ajouter un pr√©fixe si n√©cessaire
  if (config.prefix && !rewritten.toLowerCase().startsWith(config.prefix.toLowerCase())) {
    rewritten = config.prefix + rewritten;
  }
  
  return rewritten + '\n\n[R√©√©criture basique - Mistral indisponible]';
}

// IA - Fonctions d'assistance intelligente
function calculateStressLevel(title, description, priority) {
  let stress = 1;
  
  // Mots-cl√©s de stress
  const stressKeywords = ['urgent', 'deadline', 'important', 'critique', 'rush', 'asap'];
  const relaxKeywords = ['simple', 'facile', 'rapide', 'routine'];
  
  const text = (title + ' ' + description).toLowerCase();
  
  stressKeywords.forEach(keyword => {
    if (text.includes(keyword)) stress += 1;
  });
  
  relaxKeywords.forEach(keyword => {
    if (text.includes(keyword)) stress -= 0.5;
  });
  
  // Ajustement selon la priorit√©
  const priorityStress = {
    'low': 0,
    'medium': 1,
    'high': 2,
    'urgent': 3
  };
  
  stress += priorityStress[priority] || 1;
  
  return Math.max(1, Math.min(5, Math.round(stress)));
}

function generateAISuggestions(title, description) {
  const suggestions = [];
  const text = (title + ' ' + description).toLowerCase();
  
  // Suggestions de d√©coupage
  if (text.includes('projet') || text.includes('d√©velopper') || text.includes('cr√©er')) {
    suggestions.push('üí° Divisez ce projet en sous-t√¢ches plus petites');
    suggestions.push('üìã Cr√©ez un planning avec des √©tapes interm√©diaires');
  }
  
  if (text.includes('r√©union') || text.includes('meeting')) {
    suggestions.push('üìÖ Pr√©parez un agenda avant la r√©union');
    suggestions.push('üìù Notez les points cl√©s √† aborder');
  }
  
  if (text.includes('urgent') || text.includes('deadline')) {
    suggestions.push('‚è∞ Focalisez-vous sur cette t√¢che en priorit√©');
    suggestions.push('üö´ √âliminez les distractions pendant le travail');
  }
  
  return suggestions.join(' | ');
}

function parseVoiceInput(transcript) {
  const text = transcript.toLowerCase();
  
  // Extraction de la priorit√©
  let priority = 'medium';
  if (text.includes('urgent') || text.includes('important')) priority = 'urgent';
  else if (text.includes('haute priorit√©') || text.includes('high')) priority = 'high';
  else if (text.includes('basse priorit√©') || text.includes('low')) priority = 'low';
  
  // Nettoyage du titre
  let title = transcript
    .replace(/urgent|important|haute priorit√©|basse priorit√©|high|low/gi, '')
    .trim();
  
  if (title.length > 100) {
    return {
      title: title.substring(0, 100) + '...',
      description: title,
      priority
    };
  }
  
  return {
    title: title || 'T√¢che vocale',
    description: `Cr√©√©e par commande vocale: "${transcript}"`,
    priority
  };
}

// Route pour servir le frontend
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '../frontend/index.html'));
});

// Initialisation de la base de donn√©es et d√©marrage du serveur
sequelize.sync({ force: false }).then(() => {
  console.log('üóÑÔ∏è  Base de donn√©es synchronis√©e');
  app.listen(PORT, () => {
    console.log(`üöÄ Serveur d√©marr√© sur http://localhost:${PORT}`);
  });
}).catch(err => {
  console.error('‚ùå Erreur de connexion √† la base de donn√©es:', err);
});